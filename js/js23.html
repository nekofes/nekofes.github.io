<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script>if(self!=top){top.location=self.location;}</script></script><title>Javascript MEMO</title><script type = "text/javascript" src="../o/run_prettify.js"></script><link href = "../o/prettify.css" type="text/css" rel="stylesheet" />  <style>    .prettyprint ol.linenums > li {      list-style-type: decimal;     }    /* お好みでボタンのスタイルも設定 */    .copy-button {      display: inline-block; /* インライン要素をブロック要素のように扱う */      padding: 2px 5px; /* リンクテキストの周りに余白を追加 */      border: 1px solid #000; /* 枠線を追加 */      border-radius: 3px; /* 角を丸くする */      text-decoration: none; /* デフォルトの下線を消す */      color: #000; /* リンクの色 */      background-color: #ffffcc; /* 背景色を黄色に */      /* 蛍光ペン風の背景色 */      /* background: linear-gradient(transparent 60%, #ffffcc 60%); */    }    .copy-button:hover {      background-color: #ffeb99; /* ホバー時の背景色 */    }  </style></head><body oncontextmenu='return false;'><table border=0><tr><td><input type=radio id='r1' name='r1' value=0 onchange='f1(0);' checked><label for=0>日本語</label></td><td><input type=radio id='r1' name='r1' value=1 onchange='f1(1);'><label for=1>ENGLISH</label></td></tr></table><input type=hidden id=lang value=0><div id=l0><a href='#' onClick="f2();">戻る</a><br><br><table><tr><td style="font-size:150%;font-width:bold;background-color:rgb(143 188 143 / 0.4);">setIntervalとsetTimeout</td></tr><tr><td>setIntervalとsetTimeoutについて</td></tr></table><br><div style="background-color:rgb(100 149 237 / 0.2);text-align:center;">setInterval</div>指定した間隔（ミリ秒）ごとにコールバック関数を繰り返し実行するタイマーです。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">戻り値 = setInterval(関数, ミリ秒);</div><table><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">戻り値</td></tr><tr><td>タイマーを識別する正の整数の戻り値(ID)を返します。<br>※通常は、1から始まる正の整数の値です。</td></tr><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">関数</td></tr><tr><td>コールバック(繰り返し実行したい)関数を指定します。<br>関数式やアロー関数など、任意の形式で指定してください。</td></tr><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">ミリ秒</td></tr><tr><td>実行間隔を指定します。<br>ミリ秒単位で、1秒は1000ミリ秒となります。</td></tr></table><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">clearInterval</div>setIntervalのタイマー処理を停止する関数です。<br>setIntervalを実行したときに得られる戻り値を使って、タイマーを停止します。<br>(例)<br>let intervalID = setInterval(関数, ミリ秒);<br>setInterval(intervalID);<br><a href="javascript:void(0);" id="copy1" class="copy-button" data-target="codeBlock1">copy</a><pre id="codeBlock1" class="prettyprint linenums;lang-js;">
let count = 0;
console.log("start");
const intervalId = setInteval(()=>
{
	count++;
	console.log("count:"+count);
	if(count === 3)
	{
		clearInterval(intervalId);
		console.log("end");
	}
}, 1000);
</pre><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">[実行結果]</div>start<br>count:1<br>count:2<br>count:3<br>end<br><br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[delay]</div>指定された関数を繰り返し実行する間隔をミリ秒単位で指定したものとして使用しています。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[イベントループ]</div>イベントループという仕組みは非同期処理(setIntervalやsetTimeoutなど)を管理し、効率的に実行します。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[タスクキュー]</div>イベントループはタスクキューと呼ばれる場所を使い、タスクの管理をします。<br>このタスクキューで実行待ちのコールバック関数を管理します。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[コールスタック]</div>現在、実行中の関数を管理する場所です。<br>実行するとコールスタックが空になります。<br>管理する場所が空になったタイミングで、タスクキューから次のコールバック関数を取り出して、<br>コールスタックに積んで実行します。<br>このタスクキューで実行待ちのコールバック関数を管理します。<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">setIntervalとタスクキュー</div>指定された間隔でコールバック関数をタスクキューに追加します。<br>イベントループは、コールスタックが空になると、タスクキューから関数を取り出し、実行します。<br>このため、指定された間隔で関数が繰り返し、実行されるように見えます。<br><br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[注意点]</div>タイマーの誤差や、コールバック関数の実行時間によって<br>正確な間隔で実行されない場合があります。<br>コールバック関数が長い処理を実行するケース<br>他の処理によって、コールスタックが埋まっているケース<br>このような場合は、間隔がずれる可能性があります。<br><br><br><div style="background-color:rgb(100 149 237 / 0.2);text-align:center;">setTimeout</div>指定したミリ秒数だけ時間の経過後に<br>第1引数に指定した関数を1回だけ実行します。<br>1秒は1000ミリ秒なので、3000と設定すると3秒後にsetTimeoutに指定した第1引数の関数が実行されます。<br>setIntervalは指定した時間ごとに繰り返し関数を実行しますが、<br>setTimeoutは1度のみ実行するという違いがあります。<br>そのため、setTimeoutを使い、繰り返し指定したい関数を実行する場合は再帰処理などの手法を使う必要があります。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">[構文]</div>setTimeout(関数, delay, arg1, arg2, ... ,arg n);<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">関数</div>実行したい関数を指定します。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">delay</div>実行を遅延させる時間をミリ秒単位で指定します。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">arg1, arg2, ... ,arg n</div>関数の引数を指定します(省略可能)<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">(1)関数を指定する方法</div><pre id="codeBlock2" class="prettyprint linenums;lang-js;">
function printLog(text)
{
	console.log(text);
}
//2秒後に、printLog関数が実行されます
setTimeout(printlog, 2000, "test");
</pre>第1引数のprintLog関数を実行します。<br>printLog関数には引数が1個、必要としているため第3引数に"test"を設定しています。<br>第2引数に2000ミリ秒を指定しているので、2秒後にprintLog関数を実行することになります。<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">(2)無名関数を指定する方法</div><pre id="codeBlock3" class="prettyprint linenums;lang-js;">
setTimeout(() => {
	console.log("test2");
}, 3000);
</pre>無名関数を使用したサンプルです。<br>3000ミリ秒なので3秒後に無名関数を実行します。<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">clearTimeout</div>setIntervalのようにタイマーをキャンセル(停止)することができる方法が用意されています。<br>setTimeoutはタイマーを識別するための正の整数を返します。<br>clearTimeout関数を使って、戻り値であるタイマーIDを指定して実行すると<br>setTimeoutをキャンセル(停止)することができます。<br>(例)<br><pre id="codeBlock4" class="prettyprint linenums;lang-js;">
function cancelTest()<br>
{
	console.log("cancelTest");
}
//2秒後にcancelTest関数を実行
const timerId =setTimeout(cancelTest, 2000);

//タイマーをキャンセルするテスト
setTimeout(() => {
	clearTimeout(timerId);
	console.log("タイマーをキャンセルしました。");

}, 1000);

//3秒後に設定したタイマー処理
setTimeout(() => {
	console.log("3秒後に実行したタイマー処理");
}, 3000);
</pre><br>この例では2秒後にcancelTest関数を実行する予定です。<br>しかし、1秒後に無名関数でclearTimeoutを実行しています。<br>このclearTimeoutは2秒後に実行する予定のタイマーIDをキャンセルする処理です。<br>このため、先に実行したclearTimeoutのため2秒後に実行する予定のcancelTestは実行されません。<br>そして、その後、3秒後に設定したタイマー処理が実行されます。<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">setTimeoutとsetIntervalの使い分け</div><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">setTimeout</div>特定の時間間隔で一度だけ実行したい場合や、処理の完了後に次の処理を実行したい場合（非同期処理）に適しています。<br>再帰的に呼び出すことで、setIntervalと同様の繰り返し処理を実装できます。<br>処理が完了するまで次の処理を実行しないため、処理が遅延しても次の実行に影響を与えません。<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">setInterval</div>一定の間隔で定期的に処理を実行したい場合に便利です。<br>setTimeoutで再帰的に記述するよりもコードがシンプルになる場合があります。<br>処理が遅延すると、次の実行タイミングがずれてしまう可能性があります。﻿<br><br><br><br><a href='#' onClick="f2();">戻る</a></div><div id=l1><a href="#" onclick="f2();">back</a><br><br><table><tr><td style="font-size:150%;font-width:bold;background-color:rgb(143 188 143 / 0.4);">setIntervalとsetTimeout</td></tr><tr><td>about setIntervalとsetTimeout</td></tr></table><br><div style="background-color:rgb(100 149 237 / 0.2);text-align:center;">setInterval</div>A timer that repeatedly executes a callback function at the specified interval (milliseconds). <br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">Return value = setInterval(function, milliseconds);</div><table><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">Return value</td></tr><tr><td>Returns a positive integer return value (ID) that identifies the timer. <br>*Normally, this is a positive integer value starting from 1.</td></tr><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">Function</td></tr><tr><td>Specify the callback function (the function you want to execute repeatedly). <br>Specify in any format, such as a function expression or arrow function.</td></tr><tr><td style="background-color:rgb(75 0 130 / 0.2);text-align:left;">Milliseconds</td></tr><tr><td>Specify the execution interval. <br>In milliseconds, 1 function is 1000 milliseconds.</td></tr></table><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">clearInterval</div>This is a function that stops the timer processing of setInterval. <br>The timer is stopped using the return value obtained when executing setInterval. <br>(Example)<br>let intervalID = setInterval(function, milliseconds);<br><a href="javascript:void(0);" id="copy1" class="copy-button" data-target="codeBlock1">copy</a><pre id="codeBlock1" class="prettyprint linenums;lang-js;">
let count = 0;
console.log("start");
const intervalId = setInteval(()=>
{
	count++;
	console.log("count:"+count);
	if(count === 3)
	{
		clearInterval(intervalId);
		console.log("end");
	}
}, 1000);
</pre><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">[Execution result]</div>start<br>count:1<br>count:2<br>count:3<br>end<br><br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[delay]</div>It is used as the interval in milliseconds for repeatedly executing the specified function. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[Event Loop]</div>The event loop is a mechanism that manages asynchronous processing (such as setInterval and setTimeout) and executes them efficiently. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[Task Queue]</div>The event loop uses a place called the task queue to manage tasks. <br>This task queue manages callback functions waiting to be executed. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[Call Stack]</div>This is where you manage the currently executing functions. <br>When executed, the call stack will be emptied. <br>When the area to manage becomes empty, the next callback function is taken from the task queue,<br>then stacked on the call stack and executed. <br>This task queue manages the callback functions waiting to be executed. <br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">setInterval and task queue</div>Adds a callback function to the task queue at the specified interval. <br>When the call stack becomes empty, the event loop takes the function from the task queue and executes it. <br>This makes it appear as if the function is being executed repeatedly at the specified interval. <br><br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">[Notes]</div>Depending on the timer error and the execution time of the callback function,<br>it may not be executed at the correct interval. <br>When the callback function executes a long process<br>When the call stack is filled by other processes<br>In such cases, the interval may be off. <br><br><br><div style="background-color:rgb(100 149 237 / 0.2);text-align:center;">setTimeout</div>After the specified number of milliseconds has elapsed<br>The function specified in the first argument is executed only once. <br>Since there are 1000 milliseconds in one second, if you set it to 3000, the function specified in the first argument of setTimeout will be executed after 3 seconds. <br>The difference is that setInterval executes a function repeatedly at the specified time,<br>while setTimeout executes only once. <br>Therefore, if you want to use setTimeout to execute a function you want to specify repeatedly, you need to use a technique such as recursion. <br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">[Syntax]</div>setTimeout(function, delay, arg1, arg2, ... ,arg n);<br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">function</div>Specify the function you want to execute. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">delay</div>Specify the time to delay execution in milliseconds. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">arg1, arg2, ... ,arg n</div>Specify function arguments (optional)<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">(1) How to specify a function</div><pre id="codeBlock2" class="prettyprint linenums;lang-js;">
function printLog(text)
{
	console.log(text);
}
//After 2 seconds, the printLog function is executed.
setTimeout(printlog, 2000, "test");
</pre>Executes the printLog function in the first argument. <br>The printLog function requires one argument, so the third argument is set to "test". <br>The second argument is set to 2000 milliseconds, so the printLog function will be executed after 2 seconds. <br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">(2) How to specify an anonymous function</div><pre id="codeBlock3" class="prettyprint linenums;lang-js;">
setTimeout(() => {
console.log("test2");
}, 3000);
</pre>This is a sample that uses an anonymous function. <br>The anonymous function will be executed after 3 seconds, since it is 3000 milliseconds. <br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">clearTimeout</div>Like setInterval, there is a way to cancel (stop) a timer. <br>setTimeout returns a positive integer to identify the timer. <br>By using the clearTimeout function and specifying the timer ID, which is the return value,<br>you can cancel (stop) setTimeout. <br>(Example)<br><pre id="codeBlock4" class="prettyprint linenums;lang-js;">
function cancelTest()<br>
{
	console.log("cancelTest");
}
//Execute the cancelTest function after 2 seconds
const timerId =setTimeout(cancelTest, 2000);

//Test to cancel the timer
setTimeout(() => {
	clearTimeout(timerId);
	console.log("The timer was canceled.");

}, 1000);

//Timer processing set after 3 seconds
setTimeout(() => {
	console.log("Timer processing executed after 3 seconds");
}, 3000);
</pre><br>In this example, the cancelTest function is scheduled to run after 2 seconds. <br>However, after 1 second, an anonymous function executes clearTimeout. <br>This clearTimeout is a process to cancel the timer ID scheduled to run after 2 seconds. <br>As a result, cancelTest scheduled to run after 2 seconds will not be executed due to the clearTimeout that was executed first. <br>Then, the timer process set after 3 seconds will be executed. <br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">How to use setTimeout and setInterval</div><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">setTimeout</div>This is suitable when you want to execute only once at a specific time interval, or when you want to execute the next process after the process is completed (asynchronous processing). <br>By calling recursively, you can implement a repeating process similar to setInterval. <br>The next process will not be executed until the process is completed, so even if the process is delayed, it will not affect the next execution. <br><div style="background-color:rgb(75 0 130 / 0.2);text-align:left;">setInterval</div>This is useful when you want to execute a process periodically at regular intervals. <br>This may result in simpler code than writing recursively with setTimeout. <br>If the process is delayed, the timing of the next execution may be delayed. ﻿<br><br><br><br><a href="#" onclick="f2();">back</a></div><script>        function copyCodeById(targetId) {      const codeElement = document.getElementById(targetId);      if (!codeElement) {        console.error("対象のコードブロックが見つかりません: " + targetId);        return;      }            const codeText = codeElement.innerText;      if (navigator.clipboard && navigator.clipboard.writeText) {        navigator.clipboard.writeText(codeText)          .then(() => {            console.log("コピー成功");          })          .catch(err => {            console.error("コピー中にエラーが発生しました:", err);          });      } else {        console.error("Clipboard API はこのブラウザで利用できません");      }    }        document.querySelectorAll('.copy-button').forEach(function(button) {      button.addEventListener('click', function() {        const targetId = this.getAttribute('data-target');        copyCodeById(targetId);      });    });</script></script><script>window.onload = function() {f3();f0();};function f1(value){const obj=document.getElementById('lang');obj.value=value;f0();}function f0(){const obj=document.getElementById('lang');const l0=document.getElementById('l0');const l1=document.getElementById('l1');let lang=obj.value;if(lang==1){l0.style.display="none";l1.style.display="block";}else{l0.style.display="block";l1.style.display="none";}f4();}function f4(){const obj=document.getElementById('lang');let d=obj.value;let o=document.getElementsByName('r1');if(d==0){o[0].checked=true;}else{o[1].checked=true;}}function f3(){let o1=new URL(window.location.href);let o2=o1.searchParams;let d=o2.get('lang');const obj=document.getElementById('lang');if(d==1||obj.value==1){obj.value=1;}else{obj.value=0;}}function f2(){const obj=document.getElementById('lang');let lang=obj.value;let url="";if(lang==0){url='/js/index.html?lang=0';}else{url='/js/index.html?lang=1';}window.location.href=url;}function f5(no){const obj=document.getElementById('lang');let lang=obj.value;let url="";switch(no){case 1:if(lang==0){url='/js/js1.html?lang=0';}else{url='/js/js1.html?lang=1';}break;case 2:if(lang==0){url='/js/js2.html?lang=0';}else{url='/js/js2.html?lang=1';}break;}window.location.href=url;}</script></script><br><br><br><table style='background-color:rgba(220,220,220,255);color:black;text-align:center;'<tr<td style='background-color:rgba(198,198,255,255);color:black;text-align:center;'<b>著作権情報</b>	</td>	</>	<tclasp2>	<td aligleft >	ホームページおよプリ等に掲載されている情報等については、いかなる保障もいたしません。	<br />	ホームページおよびアプリ等を通じて入手したいかなる情報も複製、販売、出版または使用させたり、<br />	または公開したりすることはできません。	<br />	当方は、ホームペーよびアプリ利用したいかなる理由によっての障害等が発生しても、<br />	その結果ホームページおよびアプリ等を利用された本人または他の第三者が被った損害について<br />	一切の責任を負わないものとします。	<br />	</td>	</tr></table></body></html>
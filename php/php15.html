<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script>if(self!=top){top.location=self.location;}</script><title>PHP MEMO</title><script type = "text/javascript" src="../o/run_prettify.js"></script><link href = "../o/prettify.css" type="text/css" rel="stylesheet" /><style>.prettyprint ol.linenums > li {list-style-type: decimal; }.copy-button {display: inline-block; padding: 2px 5px; border: 1px solid #000; border-radius: 3px; text-decoration: none; color: #000; background-color: #ffffcc; }.copy-button:hover {background-color: #ffeb99; }</style></head><body oncontextmenu='return true;'><table><tr><td><label class="toggle-switch"><input type="checkbox" id="toggle"><span class="slider"></span></label></td><td><p id="langText">現在の言語: 日本語</p></td></tr></table><input type="hidden" id="lang" value="0"><a id="n1" href='#' onClick="f2();">戻る</a><br><br><table><tr><td style="font-size:150%;font-width:bold;background-color:rgb(143 188 143 / 0.4);"><div id="n2">object型</div></td></tr><tr><td><div id="n3">php型宣言</div></td></tr></table><br><div id="n4">object型はphpでクラスのインスタンスを表します。<br>クラスのインスタンス化以外には下記の内容があります。<br><br>(1)PHPの組み込み関数や機能が返すオブジェクト<br>json_decode() 関数は、デフォルトでJSON文字列をPHPのオブジェクトに変換して返します。<br>これはクラス定義のない汎用的なオブジェクト（stdClass）です。<br>$json_string = '{"name": "book", "price": 1000}';<br>$data = json_decode($json_string);<br><br>(2)データベース結果セット<br>// PDOの例 (PDO::FETCH_OBJ を使用)<br>$stmt = $pdo->query('SELECT * FROM tbl');<br>$bject = $stmt->fetch(PDO::FETCH_OBJ);<br><br>(3)配列からオブジェクトへのキャスト（変換）<br>配列を (object) のキャスト演算子を使って強制的にオブジェクトに変換できます。<br>$array_data = ['a' => 1, 'b' => 2];<br>// 配列をオブジェクトに変換<br>$object = (object) $array_data;<br><br>(4)stdClass の直接利用<br>stdClass はPHPに標準で備わっている「空っぽの汎用クラス」です。<br>これはPHPの内部で汎用オブジェクトが必要なときに使われるもので、<br>開発者がデータコンテナとして直接 new することも可能です<br>$generic_object = new stdClass();<br>$generic_object->status = "active";<br>$generic_object->num = 100;<br><br>オブジェクト以外の型を関数の型に渡した場合はエラーになります。<br>function test(object $cls)<br>{<br>&nbsp;&nbsp;...<br>}<br>$num = 100;<br>test($num);//エラーになります。<br>int/float/bool/array/null等のオブジェクト以外の型も同様にエラーとなります。<br>TypeError という実行時エラーが発生します。<br>ただし、nullを渡した場合でnull許容型を使用した場合はエラーとなります。<br>function test(?object $cls)<br>{<br>&nbsp;&nbsp;if($cls === null)<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo "nullが渡されました。";<br>&nbsp;&nbsp;}<br>}<br>test(null);//エラーにはなりません<br><br>null許容型とは引数の型に?をつけることでnullを許容する設定になります。<br><br></div><br><div id="n5">[サンプル]</div><br><div id=h1><a href="javascript:void(0);" id="copy1" class="copy-button" data-target="codeBlock1">copy</a><pre id="codeBlock1" class="prettyprint linenums;lang-js;">
class test1
{
  public int $total = 0;
  public string $result = "";
  public function test1(int $num1, int $num2)
  {
      $this->add($num1, $num2);
  }
  private function add(int $num1, int $num2)
  {
    $this->total = $num1 + $num2;
    $this->result = "$num1 + $num2 = $this->total";
  }
}
echo "&lt;pre&gt;";

$cls1 = new test1();
$cls1->test1(2, 3);
echo "total:$cls1->total".PHP_EOL;
echo "result:$cls1->result".PHP_EOL;

echo "&lt;/pre&gt;";
</pre></div><div id=h11><a href="javascript:void(0);" id="copy11" class="copy-button" data-target="codeBlock11">copy</a><pre id="codeBlock11" class="prettyprint linenums;lang-js;">
class test1
{ 
	public int $total = 0; 
	public string $result = ""; 
	public function test1(int $num1, int $num2) 
	{ 
		$this->add($num1, $num2); 
	} 
	private function add(int $num1, int $num2) 
	{ 
		$this->total = $num1 + $num2; 
		$this->result = "$num1 + $num2 = $this->total"; 
	}
}
echo "&lt;pre&gt;";

$cls1 = new test1();
$cls1->test1(2, 3);
echo "total:$cls1->total".PHP_EOL;
echo "result:$cls1->result".PHP_EOL;

echo "&lt;/pre&gt;";</pre></div><br><div id="n6">newキーワード<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$cls1 = new test1();<br></div>クラスからオブジェクトを作成します。<br>new演算子ではallocate(メモリの確保)とinitialize(初期化)の両方が同時に行われます。<br>allocやinitに相当するような明示的なメモリ割り当てステップはありません。<br>もしも初期化時点で引数に値を渡したい場合は<br>newの直後に引数を実装します。<br>(例)<br>class test<br>{<br>public function __construct($num)<br>{<br>$this->num = $num;<br>}<br>private int $num;<br>...<br>}<br>$cls = new test(100);<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">->演算子<br></div>$this->total = $num1 + $num2;<br>プロパティに値を入れたり、値を取得するため使用します。<br>また、メソッド呼び出しにも使用します。<br>$this->add($num1, $num2);<br><br></div><br><div id=h2><a href="javascript:void(0);" id="copy2" class="copy-button" data-target="codeBlock2">copy</a><pre id="codeBlock2" class="prettyprint linenums;lang-js;">
class test2
{
  function test()
  {
    return;
  }
}
echo "&lt;pre&gt;";

$obj1 = new test2();
$obj2 = new test2();
unset($obj1);
$obj2 = null;

echo "&lt;/pre&gt;";

</pre></div><div id=h22><a href="javascript:void(0);" id="copy22" class="copy-button" data-target="codeBlock22">copy</a><pre id="codeBlock22" class="prettyprint linenums;lang-js;">
class test2
{ 
	function test() 
	{ 
		return; 
	}
}
echo "&lt;pre&gt;";

$obj1 = new test2();
$obj2 = new test2();
unset($obj1);
$obj2 = null;

echo "&lt;/pre&gt;";
</pre></div><div id="n7"><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">メモリ解放<br></div>unsetやnullを使用して解放処理を実装します。<br>上記はtest2クラスをインスタンス化したオブジェクト変数をそれぞれに割り当てています。<br>例えば、このサンプルでは<br>unset($obj1);<br>と書かれていますが、<br>この後に<br>$obj1 = null;<br>としても不具合が起こることは通常ないようです。<br>ただし、冗長なコードとなってしまいます。<br>unset($obj1);<br>$obj1変数を未定義の状態にします。<br>メモリ上のオブジェクトへの参照は、ここで解除され<br>$obj1は存在しない変数として扱われます。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj1 = null;<br></div>直線のunset($obj1)により$obj1は既に存在しないことになっています。<br>そのため、nullを設定しようとしている処理は<br>何もしない、あるいは、<br>存在しない変数にnullを代入しようとしている結果<br>となります。<br>phpインタプリタは柔軟な仕組みなため、存在しない変数への代入をしても<br>致命的なエラーにはならずに、安全に処理されます。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj2 = null;<br></div>ガーベッジコレクション(GC)の対象になります。<br>これはunset($obj1);のケースも同様にガーベッジコレクションの対象となります。<br>phpのメモリ解放の仕組みは参照カウンタを使用しています。<br>変数を使用した分だけインクリメント(1個ずつ増えていく)します。<br>そして、変数が参照から外れると、その分だけマイナスになります。<br>そして変数を参照しているカウント数が0になると即座にメモリを解放します。<br>ガーベッジコレクションは参照カウンタの弱点を補うための仕組みとして採用されています。<br>参照カウンタだけでは循環参照を解決できません。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">循環参照<br></div>AがBを参照して<br>BがAを参照している<br>という両者が参照し合っている状態<br>こうなると両方のオブジェクトのカウント数が常に1以上になってしまいます。<br>そして誰も使っていないのにメモリが解放されなくなってしまうのです。<br>PHPのガーベッジコレクションは定期的にメモリが一定量士用意されたときに起動して<br>このような循環参照によって発生したゴミ(ガーベッジ)を見つけ出し<br>強制的に解放する仕組みです。<br><br></div><br><br><a id="n8" href='#' onClick="f2();">戻る</a><br><br><table style='background-color:rgba(220,220,220,255);color:black;text-align:center;'><tr><td style='background-color:rgba(198,198,255,255);color:black;text-align:center;'><b>著作権情報</b></td></tr><tr class=p2><td align=left >	ホームページおよプリ等に掲載されている情報等については、いかなる保障もいたしません。<br>ホームページおよびアプリ等を通じて入手したいかなる情報も複製、販売、出版または使用させたり、<br>または公開したりすることはできません。<br>当方は、ホームページおよびアプリ等を利用したいかなる理由によっての障害等が発生しても、<br>その結果ホームページおよびアプリ等を利用された本人または他の第三者が被った損害について<br>一切の責任を負わないものとします。<br></td></tr></table><style>.marker99ccff{background-color: rgb(153 204 255 / 0.5);}.marker8fbc8f{background-color: rgb(143 188 143 / 0.5);}.markerffd700{background-color: rgb(255 215 0 / 0.5);}.frame {background-color: rgb(240 248 255 / 0.5); border: 3px solid rgb(30 144 255 / 1.00);    padding: 5px;            margin: 10px;            margin-left:0px;word-break:break-all;}.toggle-switch {position: relative;display: inline-block;width: 60px;height: 34px;}.toggle-switch input {display: none;}.slider {position: absolute;cursor: pointer;top: 0; left: 0;right: 0; bottom: 0;background-color: lightgreen; transition: 0.4s;border-radius: 34px;}.slider:before {position: absolute;content: "";height: 26px; width: 26px;left: 4px; bottom: 4px;background-color: white;transition: 0.4s;border-radius: 50%;content:"JP";text-align: center;}input:checked + .slider {background-color: lightblue; }input:checked + .slider:before {transform: translateX(26px);content:"EN";text-align: center;}</style><script>function copyCodeById(targetId) {const codeElement = document.getElementById(targetId);if (!codeElement) {console.error("対象のコードブロックが見つかりません: " + targetId);return;}const codeText = codeElement.innerText;if (navigator.clipboard && navigator.clipboard.writeText) {navigator.clipboard.writeText(codeText).then(() => {console.log("コピー成功");}).catch(err => {console.error("コピー中にエラーが発生しました:", err);});} else {console.error("Clipboard API はこのブラウザで利用できません");}}document.querySelectorAll('.copy-button').forEach(function(button) {button.addEventListener('click', function() {const targetId = this.getAttribute('data-target');copyCodeById(targetId);});});</script><script>let lang = 0; let nextUrlPath="";const text = {ja: {n1:"戻る",n2:"object型",n3:"php型宣言",n4:`object型はphpでクラスのインスタンスを表します。<br>クラスのインスタンス化以外には下記の内容があります。<br><br>(1)PHPの組み込み関数や機能が返すオブジェクト<br>json_decode() 関数は、デフォルトでJSON文字列をPHPのオブジェクトに変換して返します。<br>これはクラス定義のない汎用的なオブジェクト（stdClass）です。<br>$json_string = '{"name": "book", "price": 1000}';<br>$data = json_decode($json_string);<br><br>(2)データベース結果セット<br>$stmt = $pdo->query('SELECT * FROM tbl');<br>$bject = $stmt->fetch(PDO::FETCH_OBJ);<br><br>(3)配列からオブジェクトへのキャスト（変換）<br>配列を (object) のキャスト演算子を使って強制的にオブジェクトに変換できます。<br>$array_data = ['a' => 1, 'b' => 2];<br>$object = (object) $array_data;<br><br>(4)stdClass の直接利用<br>stdClass はPHPに標準で備わっている「空っぽの汎用クラス」です。<br>これはPHPの内部で汎用オブジェクトが必要なときに使われるもので、<br>開発者がデータコンテナとして直接 new することも可能です<br>$generic_object = new stdClass();<br>$generic_object->status = "active";<br>$generic_object->num = 100;<br><br>オブジェクト以外の型を関数の型に渡した場合はエラーになります。<br>function test(object $cls)<br>{<br>&nbsp;&nbsp;...<br>}<br>$num = 100;<br>test($num);int/float/bool/array/null等のオブジェクト以外の型も同様にエラーとなります。<br>TypeError という実行時エラーが発生します。<br>ただし、nullを渡した場合でnull許容型を使用した場合はエラーとなります。<br>function test(?object $cls)<br>{<br>&nbsp;&nbsp;if($cls === null)<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo "nullが渡されました。";<br>&nbsp;&nbsp;}<br>}<br>test(null);<br>null許容型とは引数の型に?をつけることでnullを許容する設定になります。<br>`,n5:`[サンプル]`,n6:`newキーワード<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$cls1 = new test1();<br></div>クラスからオブジェクトを作成します。<br>new演算子ではallocate(メモリの確保)とinitialize(初期化)の両方が同時に行われます。<br>allocやinitに相当するような明示的なメモリ割り当てステップはありません。<br>もしも初期化時点で引数に値を渡したい場合は<br>newの直後に引数を実装します。<br>(例)<br>class test<br>{<br>public function __construct($num)<br>{<br>$this->num = $num;<br>}<br>private int $num;<br>...<br>}<br>$cls = new test(100);<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">->演算子<br></div>$this->total = $num1 + $num2;<br>プロパティに値を入れたり、値を取得するため使用します。<br>また、メソッド呼び出しにも使用します。<br>$this->add($num1, $num2);<br>`,n7:`<div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">メモリ解放<br></div>unsetやnullを使用して解放処理を実装します。<br>上記はtest2クラスをインスタンス化したオブジェクト変数をそれぞれに割り当てています。<br>例えば、このサンプルでは<br>unset($obj1);<br>と書かれていますが、<br>この後に<br>$obj1 = null;<br>としても不具合が起こることは通常ないようです。<br>ただし、冗長なコードとなってしまいます。<br>unset($obj1);<br>$obj1変数を未定義の状態にします。<br>メモリ上のオブジェクトへの参照は、ここで解除され<br>$obj1は存在しない変数として扱われます。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj1 = null;<br></div>直線のunset($obj1)により$obj1は既に存在しないことになっています。<br>そのため、nullを設定しようとしている処理は<br>何もしない、あるいは、<br>存在しない変数にnullを代入しようとしている結果<br>となります。<br>phpインタプリタは柔軟な仕組みなため、存在しない変数への代入をしても<br>致命的なエラーにはならずに、安全に処理されます。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj2 = null;<br></div>ガーベッジコレクション(GC)の対象になります。<br>これはunset($obj1);のケースも同様にガーベッジコレクションの対象となります。<br>phpのメモリ解放の仕組みは参照カウンタを使用しています。<br>変数を使用した分だけインクリメント(1個ずつ増えていく)します。<br>そして、変数が参照から外れると、その分だけマイナスになります。<br>そして変数を参照しているカウント数が0になると即座にメモリを解放します。<br>ガーベッジコレクションは参照カウンタの弱点を補うための仕組みとして採用されています。<br>参照カウンタだけでは循環参照を解決できません。<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">循環参照<br></div>AがBを参照して<br>BがAを参照している<br>という両者が参照し合っている状態<br>こうなると両方のオブジェクトのカウント数が常に1以上になってしまいます。<br>そして誰も使っていないのにメモリが解放されなくなってしまうのです。<br>PHPのガーベッジコレクションは定期的にメモリが一定量士用意されたときに起動して<br>このような循環参照によって発生したゴミ(ガーベッジ)を見つけ出し<br>強制的に解放する仕組みです。<br>`,n8:"戻る",},en: {n1: "back",n2: "object type",n3: "PHP type declaration",n4:`The object type represents a class instance in PHP. <br>In addition to class instantiation, it also has the following features: <br><br>(1) Objects returned by PHP built-in functions and features<br>By default, the json_decode() function converts a JSON string into a PHP object and returns it. <br>This is a generic object (stdClass) without a class definition. <br>$json_string = '{"name": "book", "price": 1000}';<br>$data = json_decode($json_string);<br><br>(2) Database Result Set<br>$stmt = $pdo->query('SELECT * FROM tbl');<br>$object = $stmt->fetch(PDO::FETCH_OBJ);<br><br>(3) Casting an Array to an Object<br>You can forcibly convert an array to an object using the (object) cast operator. <br>$array_data = ['a' => 1, 'b' => 2];<br>$object = (object) $array_data;<br><br>(4) Using stdClass Directly<br>stdClass is an "empty generic class" that comes standard with PHP. <br>It is used internally in PHP when a generic object is needed.<br>Developers can also directly use "new" as a data container.<br>$generic_object = new stdClass();<br>$generic_object->status = "active";<br>$generic_object->num = 100;<br><br>An error occurs if a type other than an object is passed to the function type. <br>function test(object $cls)<br>{<br>&nbsp;&nbsp;...<br>}<br>$num = 100;<br>test($num); Non-object types such as int, float, bool, array, and null also result in an error. <br>A runtime error called TypeError occurs. <br>However, if null is passed and a nullable type is used, an error occurs. <br>function test(?object $cls)<br>{<br>&nbsp;&nbsp;if($cls === null)<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;echo "Null was passed.";<br>&nbsp;&nbsp;}<br>}<br>test(null);<br>A nullable type is a setting that allows nulls by adding a ? to the argument type. <br>`,n5:`[Sample]`,n6:`new Keyword<br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$cls1 = new test1();<br></div>Create an object from a class. <br>The new operator simultaneously allocates and initializes memory. <br>There is no explicit memory allocation step equivalent to alloc or init. <br>If you want to pass a value to an argument during initialization, <br>Implement the argument immediately after new. <br>(Example)<br>class test<br>{<br>public function __construct($num)<br>{<br>$this->num = $num;<br>}<br>private int $num;<br>...<br>}<br>$cls = new test(100);<br><br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">->Operator<br></div>$this->total = $num1 + $num2;<br>Used to set or retrieve property values. <br>Also used to call methods. <br>$this->add($num1, $num2);<br>`,n7:`<div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">Memory Freeing<br></div>Implement the freeing process using unset or null. <br>The above assigns an object variable instantiated from the test2 class to each variable. <br>For example, this sample shows: <br>unset($obj1);<br>However, even if you add: <br>$obj1 = null;<br>after this, no problems usually occur. <br>However, this code is redundant. <br>unset($obj1);<br>Undefines the $obj1 variable. <br>The reference to the object in memory is released here, and <br>$obj1 is treated as a non-existent variable. <br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj1 = null;<br></div>The line unset($obj1) means that $obj1 no longer exists. <br>Therefore, an attempt to set it to null either does nothing or results in assigning null to a non-existent variable. <br>The PHP interpreter is flexible, so even if you assign a value to a non-existent variable, it will be processed safely and will not result in a fatal error. <br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">$obj2 = null;<br></div>This will be subject to garbage collection (GC). <br>This also applies to the case of unset($obj1);. <br>PHP's memory release mechanism uses reference counting. <br>It increments (increases by one) each time a variable is used. <br>When the variable is no longer referenced, it is decremented by that amount. <br>When the reference count for the variable reaches 0, the memory is immediately released. <br>Garbage collection is used to compensate for the weaknesses of reference counting. <br>Reference counting alone cannot resolve circular references. <br><div style="background-color:rgb(245 255 250 / 1.0);text-align:left;">Circular References<br></div>A references B<br>B references A<br>When both objects reference each other, <br>In this situation, the counts for both objects are always greater than 1. <br>This means that memory is not released even though no one is using it. <br>PHP's garbage collection system periodically activates when a certain amount of memory is available.<br>It finds and forcibly releases garbage generated by circular references like this.<br>`,n8:"back",}};function applyTextAll(lang, divIds) {divIds.forEach((id) => applyText(lang, id));}function getText(lang, divId) {return (text[lang] && text[lang][divId]) ?? (text.ja && text.ja[divId]) ?? '';}function applyText(lang, divId) {const el = document.getElementById(divId);if (!el) return;el.innerHTML = getText(lang, divId);}const ary = ["n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8"];document.addEventListener("DOMContentLoaded", () => {const toggle = document.getElementById("toggle");const hiddenLang = document.getElementById("lang");const langText = document.getElementById("langText");f4();toggle.addEventListener("change", () => {changeToggle();});});function changeToggle(){const hiddenLang = document.getElementById("lang");if (toggle.checked) {hiddenLang.value = 1;lang=1;} else {hiddenLang.value = 0;lang=0;}displayLangText();applyTextAll(lang==0?"ja":"en", ary);}function displayLangText(){const hiddenLang = document.getElementById("lang");if (hiddenLang.value == 0) {langText.textContent = "現在の言語: 日本語";} else {langText.textContent = "current language: English";}f3();f0();const obj=document.getElementById('lang');if(obj.value==1){toggle.checked=true;const hiddenLang = document.getElementById("lang");hiddenLang.value = 1;}else{toggle.checked=false;}}function f1(value){const obj=document.getElementById('lang');obj.value=value;f0();}function f0(){const obj=document.getElementById('lang');let lang=obj.value;applyTextAll(lang==0?"ja":"en", ary);f4();}function f4(){const obj=document.getElementById('lang');let lang=obj.value;const h1=document.getElementById('h1');const h2=document.getElementById('h2');const h11=document.getElementById('h11');const h22=document.getElementById('h22');if(lang==1){h1.style.display="none";h2.style.display="none";h11.style.display="block";h22.style.display="block";}else{h1.style.display="block";h2.style.display="block";h11.style.display="none";h22.style.display="none";}}function f3(){let o1=new URL(window.location.href);let o2=o1.searchParams;let d=o2.get('lang');const hiddenLang = document.getElementById("lang");if(d==1||hiddenLang.value==1){hiddenLang.value=1;}else{hiddenLang.value=0;}}function f2(){const obj=document.getElementById('lang');let lang=obj.value;window.location.href=urlPath();}function urlPath(){const obj=document.getElementById('lang');let lang=obj.value;nextUrlPath="/php/index.html";return nextUrlPath+"?lang=" + lang;}</script></body></html>